\documentclass[11pt]{article}

\usepackage[french]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\usepackage{svg}
\usepackage{amssymb}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{array}
\usepackage{comment}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\graphicspath{ {figures/} }

\title{Rapport}
\author{You}

\begin{document}
\setlength\parindent{0pt}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{Café sans-fil: \\Système de recommandation}
            
        \vspace{0.5cm}
        \LARGE
        Rapport de projet dans le cadre du cours: \\IFT 3150 - Projet d'informatique

        \vspace{3cm}
        
        \includegraphics[width=0.4\textwidth]{image_cafe.png}

        \vspace{2cm}
            
        \textbf{Auteur:} Bio Samir Gbian (20250793)

        \vspace{0.5cm}

        \textbf{Superviseur:} Louis-Edouard LAFONTANT
            
        \vfill
                    
        \Large
        Department d'Informatique et de Recherche Opérationnelle (DIRO)\\
        Université de montréal\\
        9 août 2024
            
    \end{center}
\end{titlepage}

\tableofcontents

\newpage
\listoffigures

\lstlistoflistings

\newpage
\section{Introduction}
\subsection{Contexte}
Afin d'améliorer le service des cafés étudiants de l'Université de Montréal (UdeM), le projet Café sans-fil a été initié au trimestre d'automne 2023 durant lequel furent construits l'infrastructure backend et un premier prototype de l'application. Le projet a été poursuivi au trimestre d'hiver durant lequel l'application fut évaluée et enrichi par l'ajout d'éléments à caractères sociaux tel que les évènements, reflétant mieux la nature sociale des cafés étudiants. Le lancement de la plateforme est prévue pour la fin de cet été, intégrant le travail réalisé à l'hiver et des améliorations mineures additionnelles.\\

\subsection{Problématique}
Cependant, faute d'exploitation des données fournis entre autre par les utilisateurs, l'expérience utilisateur actuelle manque grandement de personnalisation, impactant la satisfaction client. En effet, si un étudiant possède certaines restrictions ou préférences alimentaires ou des allergies, la plateforme ne l'aide nullement à satisfaire ses exigences (critères), résultant sur un plus lourd travail de recherche, pouvant décourager certains.
Cette lacune a aussi des conséquences sur les cafés, impactant les ventes et la fidélisation des clients ainsi que la prise de décision en vue d'une quelconque amélioration de leurs services et du menu. En effet, sans analyse de données, il est difficile pour les gérants d'optimiser le menu ou les services pour éviter des pertes et mieux répondre aux clients du café.\\

\subsection{Proposition}
En réponse aux problèmes énoncés, ce projet vise à mettre en place un système de recommandation utilisant les données fournies par les utilisateurs. Pour créer un moyen efficace de collecte et d'analyse de données nécessaire au système de recommandation, nous envisageons enrichir la plateforme avec de nouvelles fonctionnalités permettant aux utilisateurs de communiquer leurs préférences et réagir avec plus de choix aux propositions des cafés.

\newpage

\section{Système de recommendation}
\subsection{Introduction et définition}
À l'ère numérique actuelle, la vaste quantité d'informations et de choix disponibles peut être écrasante pour les utilisateurs, qu'ils naviguent en ligne pour acheter des produits, choisir un film à regarder ou sélectionner un restaurant pour dîner. Les systèmes de recommandation sont devenus des outils essentiels pour aider les utilisateurs à naviguer dans cette abondance d'options en leur suggérant des éléments qui correspondent à leurs préférences et à leurs besoins. Ces systèmes sont largement utilisés dans divers secteurs, tels que le commerce en ligne, le divertissement et les réseaux sociaux, où ils jouent un rôle crucial dans l'amélioration de l'expérience utilisateur et le renforcement de l'engagement.\\

Ainsi, un système de recommandation est une application logicielle qui prédit et suggère des éléments aux utilisateurs en fonction de leurs préférences, comportements et interactions. Ces éléments peuvent varier, allant des produits, services et contenus aux connexions sociales, voire aux expériences. L'objectif principal d'un système de recommandation est de filtrer de grandes quantités de données et de fournir des recommandations personnalisées qui sont les plus pertinentes pour l'utilisateur individuel.
Les systèmes de recommandation fonctionnent grâce à différentes techniques, telles que le filtrage collaboratif, le filtrage basé sur le contenu et les approches hybrides qui combinent plusieurs méthodes qui sont présentées dans la sous section suivante.


\subsection{Discussion des algorithmes}
\label{2.2}
Dans cette section, je présente les principaux algorithmes de recommendation. Pour chacun de ces algorithmes nous verront comment il fonctionne ainsi que ses points fort et ses points faibles.
\subsubsection{Filtrage collaboratif}
Le filtrage collaboratif est une technique de recommandation qui repose sur l'idée que les utilisateurs ayant montré des préférences similaires dans le passé auront des préférences similaires à l'avenir. L'algorithme peut être divisé en deux sous-catégories principales : le filtrage collaboratif basé sur les utilisateurs (user-based) et le filtrage collaboratif basé sur les éléments (item-based).\\

\textbf{Filtrage collaboratif basé sur les utilisateurs}

L'idée derrière le filtrage collaboratif basé sur les utilisateurs est de recommander à un utilisateur des éléments qui ont été appréciés par des utilisateurs similaires. La similarité entre les utilisateurs peut être mesurée par des techniques telles que la corrélation de Pearson (voir à l'annexe 8.1.1) ou le cosinus de l'angle entre les vecteurs d'attributs des utilisateurs (voir annexe 8.1.2) ou encore la similarité jaccard:
\begin{equation}
Jaccard(x, y) = \frac{\sum_{i = 1}^n X[i] \land Y[i]}{\sum_{i = 1}^n X[i] \vee Y[i]}
\end{equation}
\label{jaccard}

où $\text{Jaccard}(x, y)$ est la similarité entre l'utilisateur $x$ et l'utilisateur $y$. $X$ correspond à une liste d'attribut propre à l'utilisateur $x$ et $Y$ correspond à une liste d'attribut propre à l'utilisateur $y$. Ainsi, la similarité est calculé en prenant le quotient entre le nombre d'attributs que les deux utilisateurs ont en commun et le nombre total d'attributs.\\

\textbf{Filtrage collaboratif basé sur les éléments}

Le filtrage collaboratif basé sur les éléments recommande des éléments similaires à ceux qu'un utilisateur a déjà appréciés. La similarité entre les éléments peut être calculée de manière analogue à la similarité entre les utilisateurs, en utilisant des mesures comme la corrélation ou la distance cosinus ou la similarité jaccard.\\

Cet algorithme fait partie des algorithmes les plus utilisés pour effectuer des recommendations. Il est souvent utilisé pour faire des recommendation de films (sur Netflix par exemple) à des utilisateurs basé sur le profile des personnes amis et/ou similaire à l'utilisateur à qui les recommendations sont faites. Il est également présent dans les recommendation faite au niveau des réseaux sociaux comme instagram, X(Twitter), TikTok etc.

\subsubsection{Filtrage basé sur le contenu}
Le filtrage basé sur le contenu repose sur les caractéristiques des éléments eux-mêmes pour effectuer des recommandations. Donc, il n'a besoin que des informations liées à l'utilisateur (historique de visionnage ou d'achat, items aimés...). L'idée est de recommander à l'utilisateur des éléments similaires à ceux qu'il a déjà appréciés en se basant sur les attributs des éléments.

Par exemple, dans un système de recommandation de films, on pourrait représenter chaque film par un vecteur de caractéristiques ou d'attribut (comme le genre, les acteurs, le réalisateur, etc.). Le système recommande alors des films similaires à ceux que l'utilisateur a déjà notés positivement, en utilisant des mesures de similarité.

\subsubsection{Recommendation basé sur les connaissances}
Les systèmes de recommandation basés sur les connaissances utilisent des informations explicites sur les préférences et les besoins des utilisateurs pour faire des recommandations. Contrairement au filtrage collaboratif ou au filtrage basé sur le contenu, qui dépendent des données historiques d'utilisation, les systèmes basés sur les connaissances utilisent des règles ou des contraintes spécifiques pour effectuer des recommandations.\\

Par exemple, un système de recommandation de voitures pourrait utiliser des informations sur les besoins spécifiques d'un utilisateur (comme la taille de la voiture, le budget, et les préférences en matière de carburant) pour recommander des voitures adaptées.\\

L'une des approches les plus courantes est la correspondance entre les caractéristiques de l'utilisateur et celles des éléments, en utilisant des règles définies par les experts du domaine. Par exemple, si un utilisateur indique qu'il a un budget limité et préfère une voiture économique, le système recommandera des voitures correspondant à ces critères.

\subsubsection{Avantages et Inconvénients}

Chaque méthode de recommandation a ses propres avantages et inconvénients. Le filtrage collaboratif est puissant mais souffre du problème de démarrage à froid (cold start), où il est difficile de faire des recommandations pour de nouveaux utilisateurs ou de nouveaux éléments. Le filtrage basé sur le contenu peut contourner ce problème, mais il peut parfois être trop restrictif, ne recommandant que des éléments très similaires à ceux déjà appréciés par l'utilisateur. Les systèmes basés sur les connaissances, bien qu'ils puissent fournir des recommandations très pertinentes, nécessitent une connaissance experte et peuvent être difficiles à maintenir à grande échelle.

\subsubsection{Systèmes hybrides}
Un système de recommandation hybride combine plusieurs approches de recommandation pour améliorer la qualité et la précision des recommandations. Contrairement aux systèmes de recommandation purement collaboratifs ou basés sur le contenu, les systèmes hybrides utilisent des techniques variées pour exploiter les forces et compenser les faiblesses de chaque méthode individuelle. Un exemple de système hybrique serait un système qui intégrerait les algorithmes de filtrage collaboratif, filtrage basé sur le contenu et filtrage basé sur les connaissances. \\

Cela permettrait de réduire le problème de démarage à froid tout en faisant des recommendations qui ne sont pas trop restrictifs. Un tel système aura aussi la possibilité de faire des recommendation basé sur les préférences de l'utilisateur.\\

En combinant plusieurs sources d'informations, les systèmes hybrides peuvent fournir une couverture plus large des éléments recommandés, augmentant ainsi la diversité des recommandations proposées aux utilisateurs.\\

Cependant, la mise en œuvre d'un système hybride peut être plus complexe en raison de la nécessité de gérer et d'intégrer différentes techniques de recommandation. Ce type de système peut-être plus difficile à optimiser en raison des différentes combinaisons possible d'algorithmes. Elle peuvent être également couteuse en terme de calcul et de stockage.


\subsubsection{Autre algorithmes}

\textbf{Recommendation basé sur des models}\\
Un système de recommandation basé sur les modèles est un type de système de recommendation qui fournit des recommandations personnalisées aux utilisateurs en utilisant des modèles d’apprentissage automatique (réseaux de neurones, classification Bayésienne, machines à vecteurs de support) pour prédire une note qu’un utilisateur attribuerait à un article ou des items qu'un utilisateur aimerait par exemple. Après que le modèle a été entraîné, l’article avec le plus grand score est recommandé à l’utilisateur.

Une sous-catégorie des systèmes de recommandation basés sur les modèles est le filtrage collaboratif basé sur les modèles. Il utilise des modèles pour prédire l’évaluation par les utilisateurs des éléments non notés. Il existe deux grands types de filtrage collaboratif par article : les modèles binaires qui se basent uniquement sur le fait qu’un utilisateur ait acheté/sélectionné/coché ou non un bien donné, et les modèles avec évaluations où les utilisateurs sont invités à noter les différents produits.

%\textbf{Recommendation basé sur la diffusion}

%\subsection{Exemples}

\newpage
\section{Conception}
Dans cette section, je présenterai comment chacun des algorithmes de recommendation est intégré à l'application web \textit{Café sans-fil}. La figure ci-dessous présente une vue haut niveau des différents algorithmes de recommendations. Chaque diagramme (représentant un algorithme) sera présenté dans les sections suivantes. Le pseudo code décrivant plus spéciquement les algorithmes se trouve à \hyperref[annexe]{\textit{l'annexe}}.
\begin{figure}[h]
%\includegraphics[scale=0.3]{Pipeline.jpg}
%\includesvg[scale=0.3]{Pipeline.drawio.svg}
\includegraphics[scale=0.3]{Pipeline.drawio.png} 
\caption{Architecture des algorithmes}
\end{figure}

\subsection{Recommendation public (globales) d'items}
Les recommendations publiques s'addressent à toute la communauté étudiante ainsi que les professeurs. Elles se basent sur les items les plus aimés (likés) et les items les plus achetés par l'ensemble des utilisateurs. Ces recommendations sont affichées à titre indicatif pour l'utilisateur dans le sens où il pourra savoir, de façon global, qu'est-ce que les autres utilisateurs apprécient.\\

Cet algorithme fonctionne principalement par filtrage. En effet, pour un menu donné (un ensemble d'items), un premier filtrage est éffectué en conservant uniquement les items possédent le plus grand nombre de likes. Ensuite, parmi les items les plus aimés, un second filtrage est effectué pour conserver les items les plus achetés. Le nombre d'items conservé est limité à 10 pour ne pas surchargé l'interface au niveau du front-end.

\subsection{Recommandations Personnalisées}
Contrairement aux recommandations publiques, les recommandations personnalisées sont spécifiquement adaptées à chaque utilisateur. Elles s’appuient sur les trois algorithmes présentés précédemment dans la \hyperref[2.2]{\textit{section 2.2}}. Les recommandations personnalisées se déclinent en deux catégories : les recommandations d'items et les recommandations de cafés. Le système de recommandations d'items suggère des articles aux utilisateurs en utilisant les trois algorithmes mentionnés. Pour les recommandations de cafés, le filtrage collaboratif est utilisé de manière similaire, à la différence que les \textit{outputs} des recommandations sont des cafés. Cependant, le filtrage basé sur le contenu est partiellement appliqué aux café alors que les recommandations basées sur les connaissances ne sont pas appliqués aux cafés.

\subsubsection{Filtrage Collaboratif}
Dans le cadre de \textit{Café sans-fil}, l'algorithme de filtrage collaboratif repose sur la similarité entre un utilisateur et les autres. La similarité entre deux utilisateurs est calculée en utilisant la \hyperref[jaccard]{\textit{similarité Jaccard}}. Les caractéristiques utilisées pour évaluer cette similarité incluent : les items aimés par l'utilisateur, les items achetés, et les cafés visités. Ces caractéristiques ont été sélectionnées car elles reflètent fidèlement les habitudes de consommation propres à chaque utilisateur. Une fois la similarité calculée sur la base de ce vecteur d'attributs, seuls les utilisateurs présentant une similarité supérieure à un certain seuil sont retenus. Ce seuil est fixé à 60\% pour les données de test, mais il sera ajusté lors du déploiement sur des données réelles.\

Si un item acheté par un utilisateur sélectionné n'a pas encore été acheté par l'utilisateur cible, un score (correspondant à la similarité entre les deux utilisateurs) est attribué à cet item. Pour les recommandations de cafés, ce score est attribué au café.

\subsubsection{Filtrage Basé sur le Contenu}
Dans le contexte de \textit{Café sans-fil}, les recommandations basées sur le contenu, en ce qui concerne les items, se fondent sur les groupes d'items les plus appréciés ainsi que sur la similarité entre ces items. Lors du prétraitement des données, les items sont regroupés en fonction de leur similarité à l'aide de l'algorithme de clustering \textit{KMeans}. Chaque cluster reçoit un score représentant le nombre d'items aimés par l'utilisateur dans ce cluster. Les clusters ayant le plus grand nombre de likes correspondent donc aux préférences de l'utilisateur. Ensuite, pour chaque cluster préféré, un score est attribué aux items de ce cluster que l'utilisateur n'a pas encore achetés, correspondant au score du cluster.\

En ce qui concerne les cafés, aucun clustering n'est effectué. Seuls les cafés offrant le plus d'items appréciés par l'utilisateur sont proposés. Dans ce cas, le score représente le nombre d'items aimés par l'utilisateur dans un café.

\subsubsection{Recommandations Basées sur les Connaissances}
Tout comme les recommandations globales, les recommandations basées sur les connaissances fonctionnent par filtrage. Une interface utilisateur (profil nutritionnel) a été ajoutée pour collecter les préférences nutritionnelles des utilisateurs. Cette interface est présentée plus en détail dans la \hyperref[implementation]{\textit{section 4}}. À travers cette interface, il est possible de récupérer diverses préférences utilisateur telles que les régimes alimentaires suivis, les préférences nutritionnelles, et les allergies. Ensuite, les items du menu sont filtrés pour ne conserver que ceux compatibles avec le régime alimentaire choisi par l'utilisateur. Un second filtrage est appliqué pour respecter les autres préférences de l'utilisateur. Enfin, si certains items contiennent des allergènes de niveau 2 ou 3, ils sont retirés de la liste.

\subsubsection{Robot de Recommandation Santé}
Le robot de recommandation santé est conçu pour intégrer des items sains dans les recommandations personnalisées et publiques. Les items sont triés par ordre croissant de leur score santé (plus le score est bas, plus l'item est sain) et les items les plus sains sont ensuite intégrés aux recommandations. Cela vise à encourager la communauté étudiante à consommer davantage de produits sains.

\subsection{Score santé}
Les recommendations ne sont pas uniquement faites aux utilisateurs en se basant sur leur préférences et habitudes de consommation. En effet, chaque item possède un score santé représentant à quel point cet item est bon pour la santé des utilisateurs. Le score utilisé est le \textit{Nutri-score}.\\

\textbf{Nutri-score}\\

Le Nutri-Score est un système d'étiquetage nutritionnel visant à fournir une évaluation globale de la qualité nutritionnelle des aliments et boissons.\\

Il est basé sur un algorithme qui calcule un score nutritionnel global pour chaque produit. Ce score est déterminé en prenant en compte plusieurs critères nutritionnels, tels que :\\

\begin{itemize}
    \item[$\circ$] Éléments favorables : Les nutriments et composés bénéfiques pour la santé, tels que les fibres, les protéines, et les fruits et légumes. Plus la présence de ces éléments est élevée, plus le score est favorable.\\
    
    \item[$\circ$] Éléments défavorables : Les nutriments et composés potentiellement nocifs, comme les acides gras saturés, les sucres ajoutés et le sel. Plus la présence de ces éléments est élevée, plus le score est défavorable.\\
\end{itemize}

Le score final est calculé en soustrayant le total des points obtenus pour les éléments défavorables du total des points obtenus pour les éléments favorables. Lorsque le score est affiché aux consommateurs, ce dernier est ensuite converti en une lettre allant de \textbf{A} (meilleure qualité nutritionnelle) à \textbf{E} (moins bonne qualité nutritionnelle). Cependant, dans le projet, puisque ce score n'est pas afficher au grand publique, il est concervé en valeur décimal dans le but de faciliter les calculs effectuer plus tard.\\

\textbf{Pourquoi le Nutri-score ?}\\

Plusieurs raisons justifient le choix de ce score:\\

\begin{itemize}

    \item[$\circ$] Standardisation : Le Nutri-Score offre un standard uniforme pour l'évaluation nutritionnelle, ce qui permet une comparaison cohérente entre différents produits, indépendamment des variations dans les étiquetages ou les allégations marketing.\\

    \item[$\circ$] Support pour les politiques de santé publique : En fournissant une information nutritionnelle transparente et accessible, le Nutri-Score soutient les initiatives de santé publique visant à réduire les maladies liées à l'alimentation et à promouvoir une meilleure santé globale.
\end{itemize}


\newpage
\section{Implémentation}
\label{implementation}
\subsection{Spécification}
\subsection{Illustration}

\newpage
\section{Évaluation}
Pour s'assurer du bon fonctionnement des algorithmes intégrés à l'application web, des tests ont été éffectués tout au long du dévellopement. Les tests encourus sont divisés en 2 catégories:\\

\begin{itemize}
	\item[$\bullet$] \textbf{Tests fonctionnels (à la boite noire)}: Ils vérifient la conformité du code aux exigences en évaluant si les sorties correspondent aux attentes pour des entrées données, sans se soucier des détails internes du programme.\\
	
	\item[$\bullet$] \textbf{Tests d'utilisabilité}: Ils permettent de déterminer dans quelle mesure un produit ou un service (généralement une interface utilisateur ou un site web) est facile à utiliser pour les utilisateurs réels. Ces tests sont conçus pour identifier les problèmes d'utilisabilité, recueillir des données qualitatives et quantitatives, et améliorer l'expérience utilisateur.\\
\end{itemize}

Pour vérifier et valider que l'ajout de nouveaux endpoints ne provoque pas de changements indésirables dans l'application, une série de tests unitaires et de tests d'intégration a été réalisée.

\subsection{Tests}
La librairie \textit{unittest} de Python a été choisie pour effectuer les tests unitaires en raison de sa simplicité d'utilisation et de mon expérience antérieure avec cet outil.

\subsubsection{Tests unitaires}
Un total de 75 tests unitaires ont été réalisés. Environ 63 tests ont été créés pour garantir le bon fonctionnement des algorithmes, et 12 autres pour vérifier le bon fonctionnement des nouveaux endpoints de l'API. Les tests API sont structurés de manière cohérente avec ceux déjà en place.\\

Les tests des algorithmes sont structurés comme suit :
\begin{enumerate}
	\item Chaque script contenant les tests d'un algorithme est subdivisé en \textit{class}. Chaque \textit{class} contient les différents tests correspondant à une méthode intermédiare utilisé dans l'algorithme. Ainsi, chaque méthode dans la \textit{class} s'assure de tester d'une ou de plus manière la fonction à tester. L'algorithme possède aussi une \textit{class} contenant ses tests. Si des méthodes intermédiaires ne nécéssitent qu'un seule cas de test, ces dernières sont inclusent dans la même \textit{class} de test que l'algorithme princiapale.
	
	\item Dans le but de controller le mieux possible l'environement de test, les mocks sont utilisés pour éviter de biaiser le fonctionnement des algorithmes. Ainsi, ces derniers sont utilisés uniquement sur les méthodes faisant appel à l'API. Cela permet de s'assurer que si un test échoue, l'erreur est uniquement lié à l'algorithme lui même ou à son implémentation et non à un problème au niveau de l'API.
	
	\item Chaque \textit{class} de test contient, si nécessaire, une méthode \textit{setUp} qui permet d'initialiser les objets utilisés par plusieurs tests. Si un objet spécifique est requis pour faire un test et qu'il n'est requis que pour ce test, il est rajouté uniquement dans la méthode test.
	
	\item Les tests unitaires suivent le style \textbf{AAA}: \textbf{Arrange} (section du test initialisant les objets utilisé par la méthode à tester), \textbf{Act} (section où l’on invoque la méthode testée avec les paramètres créés précédemment) et \textbf{Assert} (section vérifiant que la méthode produit le comportement désiré).\\
\end{enumerate}

La figure ci-dessous est un test unitaire vérifiant que l'algorithme de filtrage basé sur le contenu retourne bien les items qu'il devrait retourner dans le cas où un utilisateur a déjà acheté tous les items d'un café.

\begin{lstlisting}[language=Python, caption=Méthode setUp]
class TestContentBasedFiltering(unittest.TestCase):

    def setUp(self):
        self.user1 = {'user_id': 'user1', 'username': 'username1'}
        self.cafes = [
            # Cafe1 doesn't contain user2
            {
                'slug': 'cafe1',
                'menu_items': [
                    {'slug': 'item1', 'likes': []}, 
                    {'slug': 'item2', 'likes': ['user1']},
                    {'slug': 'item3', 'likes': ['user5', 'user3']},
                    {'slug': 'item4', 'likes': ['user1', 'user3']},
                    {'slug': 'item5', 'likes': ['user6', 'user3', 'user4']}
                ]
            }, 

            # Cafe2 doesn't contain user1
            {
                'slug': 'cafe2',
                'menu_items': [
                    {'slug': 'item6', 'likes': ['user3', 'user2']}, 
                    {'slug': 'item7', 'likes': ['user7', 'user3', 'user4']},
                    {'slug': 'item8', 'likes': ['user2', 'user3']},
                    {'slug': 'item9', 'likes': ['user2', 'user4', 'user5', 'user6']},
                    {'slug': 'item10', 'likes': []}
                ]
            }
        ]

        self.all_items = ([
            {'slug': 'item1', 'likes': []}, 
            {'slug': 'item2', 'likes': ['user1']},
            {'slug': 'item3', 'likes': ['user2', 'user3']},
            {'slug': 'item4', 'likes': ['user1', 'user3']},
            {'slug': 'item5', 'likes': ['user2', 'user3', 'user4']},
            {'slug': 'item6', 'likes': ['user1', 'user2']}, 
            {'slug': 'item7', 'likes': ['user1', 'user3', 'user4']},
            {'slug': 'item8', 'likes': ['user2', 'user3']},
            {'slug': 'item9', 'likes': ['user1', 'user4', 'user5', 'user6']},
            {'slug': 'item10', 'likes': []}
        ], 200)

        self.cafe_items = [
            {'slug': 'item1', 'cluster': '0', 'likes': ['user1']}, 
            {'slug': 'item2', 'cluster': '1', 'likes': ['user1']},
            {'slug': 'item3', 'cluster': '2', 'likes': ['user5', 'user3']},
            {'slug': 'item4', 'cluster': '0', 'likes': ['user1', 'user3']},
            {'slug': 'item5', 'cluster': '1', 'likes': ['user6', 'user3', 'user4']}
        ]
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Test unitaire test\_main\_4 content based filtering]
class TestContentBasedFiltering(unittest.TestCase):
    # autres methodes de la classe
    
    @patch('recommender_systems.utils.api_calls.CafeApi.get_all_items')
    @patch('recommender_systems.utils.db_utils.get_user_likes_in_cafe')
    @patch('recommender_systems.utils.utilitaries.items_not_bought_in_cafe')
    def test_main_4(self, mock_items_not_bought_in_cafe, mock_get_user_likes, mock_api_get_all_items):
        # ARRANGE: Recuperation des objets de la methode setUP
        user = self.user1
        cafe = self.cafes[0]

        # Mock d'un appel de l'API
        mock_api_get_all_items.return_value = ([
            {'slug': 'item1', 'likes': []}, 
            {'slug': 'item2', 'likes': ['user1']},
            {'slug': 'item3', 'likes': ['user5', 'user3']},
            {'slug': 'item4', 'likes': ['user1', 'user3']},
            {'slug': 'item5', 'likes': ['user6', 'user3', 'user4']}
        ], 200)

        # Mocking
        mock_items_not_bought_in_cafe.return_value = set()
        mock_get_user_likes.return_value = ['item2', 'item4']
        
        # ACT et ASSERT
        self.assertCountEqual(main(user, cafe), ['item2', 'item4'])

        # Mocking
        mock_get_user_likes.return_value = []
        mock_items_not_bought_in_cafe.return_value = set()

        # ACT et ASSERT
        self.assertCountEqual(main(user, cafe), ['item5', 'item4', 'item3', 'item2', 'item1'])

    # autres methodes de la classe
\end{lstlisting}

\subsubsection{Tests d'utilisatbilité}
Une fois une première version de l'interface pour le profil nutritionnel complétée, des tests d'utilisabilité ont été réalisés. Lors d'une foire aux projets qui s'est tenue le jeudi 25 juillet, il a été possible de recueillir des retours de la part des autres étudiants, ce qui a permis d'améliorer la présentation de l'interface utilisateur ainsi que l'expérience utilisateur du profil.\

De plus, j'ai présenté l'application à certains membres de ma famille peu familiers avec les outils informatiques, dans le but d'obtenir des retours plus diversifiés. Ces commentaires ont été très pertinents pour améliorer l'expérience utilisateur de l'interface initiale.\

Un commentaire fréquemment revenu concernait le manque d'animations dans le profil, qui sera une piste d'amélioration pour l'avenir.

\subsection{Discussion}
Cette section est dédiée à effectuer des remarques et critiques sur les algorithmes. Les critiques seront effectués par rapport à l'optimalité (complexité et Scalabilité) et la robustesse de l'algorithme. Puisque les algorithmes de recommendation des cafés sont très similaires aux algorithmes de recommendations personnelles, les critiques de ces dernières sont aussi valables pour les cafés.

\subsubsection{Filtrage collaboratif}
\begin{itemize}
	\item[$\bullet$] \textbf{Complexité temporelle:} Cet algorithme calcule la similarité entre l'utilisateur cible et tous les autres utilisateurs, ce qui peut entraîner une complexité de l'ordre de $O(n \times m)$, où $n$ est le nombre d'utilisateurs et $m$ est le nombre d'attributs comparés. Bien que cette approche soit fonctionnelle pour des jeux de données de taille modérée, elle devient peu optimale lorsque le nombre d'utilisateurs augmente significativement. Pour des systèmes à grande échelle comme l'\textit{UdeM} (l'université contient environ 67000 étudiants !), cela pourrait ralentir les performances, nécessitant potentiellement des techniques de réduction de la dimensionnalité comme les méthodes \textit{PCA} et \textit{MDS} pour réduire les nombre d'éléments à comparer lors du calcul de la similarité tout en conservant le plus d'information dans les données. L'utilisation des méthodes de clustering comme \textit{KMeans} pour regrouper les utilisateurs permettrait aussi d'améliorer sinificativement l'efficacité.\\
	
	\item[$\bullet$] \textbf{Scalabilité:} Comme mentionné précédement, cet algorithme peut rencontrer des difficultés à s'adapter à un grand nombre d'utilisateurs ou de données en raison de la nécessité de calculer des similarités entre chaque paire d'utilisateurs. Dans les cas où le nombre d'utilisateurs est très élevé, des approches alternatives comme le filtrage collaboratif basé sur des modèles (qui se trouve dans la famille des recommendations basé sur les models) seraient plus efficaces.\\
	
	\item[$\bullet$] \textbf{Robustesse:} Les différents scénarios possibles sont pris en compte par l'algorithme mais une meilleure gestion des erreurs et des exceptions, notamment en ajoutant des logs plus détaillés, améliorerait sa robustesse et faciliterait le débugage.\\
	
	\item[$\bullet$] \textbf{Réutilisabilité:} L'algorithme est étroitement couplé avec des appels à des utilitaires spécifiques, ce qui pourrait limiter sa réutilisabilité dans d'autres contextes ou projets. Une approche consistant à abstraire ces dépendances rendrait l'algorithme plus modulaire et adaptable à différents environnements ou bases de données.\\
	
	\item[$\bullet$] \textbf{Extensibilité:} L'algorithme pourrait être plus flexible en permettant l'utilisation de différentes métriques de similarité ou en adaptant dynamiquement le seuil de similarité en fonction des besoins spécifiques de l'utilisateur ou du contexte.\\
	
\end{itemize}

En somme, pour une portentille amélioration de l'algorithme, il faudrait donc diminuer la dépendance de l'algorithme à d'autres modules de l'application, utiliser des méthodes de clustering ou de réduction de dimentionnalité pour augmenter son éfficacité et afficher des logs plus détaillés pour faciliter la maintenance des algorithmes.

\subsubsection{Filtrage basé sur le contenu}

\begin{itemize}
	\item[$\bullet$] \textbf{Complexité temporelle:} L'algorithme regroupe les items en clusters et itère sur ces derniers pour trouver ceux que l'utilisateur a le plus appréciés. La complexité de cette opération dépend du nombre de clusters et d'items par cluster. Similairement à l'algorithme de filtrage collaboratif, cette méthode pourrait rencontrer des problèmes de performance lorsque le nombre de clusters ou d'items est très élevé. L'utilisation d'une approche de pré-traitement, comme l'indexation inversée, pourrait potentiellement réduire les coûts de recherche.\\
	
	\item[$\bullet$] \textbf{Scalabilité:} Le processus de sélection des clusters les plus appréciés pourrait être optimisé en pré-calculant et en stockant les résultats des préférences de l'utilisateur, plutôt que de les recalculer à chaque exécution de l'algorithme. Donc, il serait plus efficade de créer une routine qui calculerait les clsuters favoris de l'utilisateur et qui les mettrait à jour dans la base de données.\\
	
	\item[$\bullet$] \textbf{Robustesse:} Comme pour le filtrage collaboratif, l'ajout de logs plus détaillés permettront faciliteront le débugage et augmentront la robustesse de l'algorithme.\\

	\item[$\bullet$] \textbf{Réutilisabilité:} L'algorithme est assez spécifique dans l'ensemble même si certaines composantes (script pour trouver les clusters favoris par exemple) peuvent être réutilisés dans d'autres contextes.\\
		
\end{itemize}

En somme, l'utilisation d'indexage inversé, la réduction de la dépendance de l'algorithem avec d'autres modules de l'application ainsi l'ajout de meilleurs logs pour le débugage seraient des modifications qui améliorerait l'algorithme dans son ensemble.

\subsubsection{Filtrage basé sur les connaissances}

\begin{itemize}
	\item[$\bullet$] \textbf{Complexité temporelle et scalabilité:} La complexité temporelle est de l'ordre de $O(n \times m \times k)$ dans le pire cas (l'utilisateur spécifie des préférences nutrives et des régimes alimentaires) où $n$ est le nombre d'items, $m$, le nombre de régimes alimentaire et $k$, le nombre de filtrages appliqués. Cet algorithme est acceptable avec une quantité faible ou moyenne de données mais, lorsque le nombre de données est élevé, la perfommance de l'algorithme pourrait significativement diminuer en raison des multiples filtrages qui sont appliqués. L'algorithme pourrait être amélioré en utilisant d'avantages des structures de données appropriées (les ensembles et dictionnaires), en évitant les calculs répétitifs (comme les comparaisons redondantes) et en réduisant le nombre d'opérations coûteuses.\\
		
	\item[$\bullet$] \textbf{Robustesse et réutilisatbilité :} Les commentaires faites aux algorithmes précédents s'appliquent aussi à cet algorithme.\\
	
	\item[$\bullet$] \textbf{Extensibilité:} Le point fort de cet algorithme serait son extensibilité en ce sens qu'il est très facile de rajouter de nouveaux filtres. Cependant, il serait quand même plus inérressant pour facilité l'ajout de nouveaux filtres, de regrouper les différents filtres dans un script différent de celui de l'algorithme.\\
	
\end{itemize}

En résumé, cet algorithme souffre des même problème de robustesse et de réutilisabilité que les autres algorithme en ce sens qu'il dépend beaucoup trop des modules spécifiques à l'application web \textit{Café sans-fil}. L'algorithmes serait donc plus optimal dans l'ensemble en réduisant la dépendance avec d'autres modules de l'application et en ajoutant de meilleurs logs pour le débugage.

\newpage
\section{Conclusion}

\newpage
\section{Remerciement}

\newpage
\section{Références}

\newpage
\section{Annexe}
\subsection{Autres mesures de similarité}
\subsubsection{Corrélation de Pearson}
Soit $u$ et $v$ deux utilisateurs. 
\begin{equation}
\rho(u, v) = \frac{\sum_{i \in I_{uv}} (r_{u,i} - \overline{r}_u)(r_{v,i} - \overline{r}_v)}{\sqrt{\sum_{i \in I_{uv}} (r_{u,i} - \overline{r}_u)^2}\sqrt{\sum_{i \in I_{uv}} (r_{v,i} - \overline{r}_v)^2}}
\end{equation}

où $\rho(u, v)$ est la similarité entre l'utilisateur $u$ et l'utilisateur $v$, $r_{u,i}$ est la note de l'utilisateur $u$ pour l'élément $i$, et $I_{uv}$ est l'ensemble des éléments évalués par les deux utilisateurs $u$ et $v$.

\subsubsection{Similarité cosinus}
Soit $u$ et $v$ deux utilisateurs. 
\begin{equation}
cos(X, Y) = \frac{\langle X, Y \rangle}{||X|| ||Y||}
\end{equation}

où $cos(X, Y)$ est la similarité entre le vecteur d'attributs $X$ de l'utilisateur $x$ et le vecteur d'attributs $Y$ de l'utilisateur $y$.


\newpage
\subsection{Pseudo codes des algorithmes de recommandation}
\label{annexe}
\subsubsection{Méthodes utilitaires}
\begin{algorithm}
    \caption{Repas pas encore consommés}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Menu du restaurant ($M$), utilisateur actuel ($u$)
    \Statex \textbf{Sortie:} Liste de repas
    \State \textbf{\textit{Algorithme(M[1...n], u)}}
    \State \hspace{0.5cm} $L \leftarrow u.historique\_achat$
    \State \hspace{0.5cm} \textbf{Pour chaque} repas $r \in L$
    \State \hspace{1cm} \textbf{Si} $r \in M$:
    \State \hspace{1.5cm} $M.retirer(r)$
    \State \hspace{0.5cm} \textbf{retourner} $M$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Mesure similarité: Jaccard}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Deux listes ou ensembles ($L_1, L_2$)
    \Statex \textbf{Sortie:} Nombre décimal représentant la similarité
    \State \textbf{\textit{Jaccard($L_1[1...n]$,$L_2[1...m]$):}}
    \State \hspace{0.5cm} $union \leftarrow L_1 \cup L_2$
    \State \hspace{0.5cm} $inter \leftarrow L_1 \cap L_2$
    \State \hspace{0.5cm} \textbf{retourner} $inter.length/union.length$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Clusters en fontion des préférences de l'utilisateur}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Menu du restaurant ($M$)
    \Statex \textbf{Sortie:} Liste des régimes contenant les catégories de repas
    \State \textbf{\textit{clusters(M[1...n])}}
    \State \hspace{0.5cm} // Nous avons k régimes différents et p catégories de repas
    \State \hspace{0.5cm} $R \leftarrow [[0...n]...k]$
    \State \hspace{0.5cm} \textbf{Pour chaque} repas $r \in M$:
    \State \hspace{1cm} mettre le repas dans un ensemble en fonction de son régime
    \State \hspace{1cm} rajouter les différents régimes de repas à $R$
    \State \hspace{0.5cm} \textbf{Pour chaque} régime $T[1...\ell] \in R$ 
    \State \hspace{1cm} mettre chaque repas du même régime dans une catégorie 
    \State \hspace{0.5cm} \textbf{retourner} $R[[[0...n]...p]...k]$
    \end{algorithmic}
\end{algorithm}

\newpage
\subsubsection{Algorithmes principales}
\begin{algorithm}
    \caption{Collaborative filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les similarités entre utilisateurs.
        \Statex \textbf{Entrée:} Liste des utilisateurs de l'application ($U$), utilisateur ($u$)
        \Statex \textbf{Sortie:} Liste $L$ des recommandations
        \State \textbf{\textit{Algorithme(U[1...n], u):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} $\tau \leftarrow$ seuil de similarité 
        \State \hspace{0.5cm} $S \leftarrow U.retirer(u)$
        \State \hspace{0.5cm} $L_u \leftarrow$ [[u.likes], [u.repas\_consommés], [u.cafés\_visités]]
        \State \hspace{0.5cm} \textbf{Pour chaque} utilisateur $x\in S_{n\times 1}$
        \State \hspace{1cm} $L_x \leftarrow$ [[x.likes], [x.repas\_consommés], [x.cafés\_visités]]
        \State \hspace{1cm} $J \leftarrow [vide]$
        \State \hspace{1cm} \textbf{Pour} $i \leftarrow 0$ à $L_x.length$
        \State \hspace{1.5cm} $j \leftarrow Jaccard(L_u[i], L_x[i])$
        \State \hspace{1.5cm} $J.ajouter(j)$
        \State \hspace{1cm} $score \leftarrow sum(J)$
        \State \hspace{1cm} \textbf{Si} $score \geq \tau$:
        \State \hspace{1.5cm} $L \leftarrow (L_x[0] \cup L_x[1]) \backslash (L_u[0] \cup L_u[1])$
        \State \hspace{1cm} $S.retirer(x)$
        \State \hspace{0.5cm} \textbf{retourner} $L$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Content based filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les habitudes de consommation de l'utilisateur.
        \Statex \textbf{Entrée:} Menu du cafe ($M$), utilisateur ($u$)
        \Statex \textbf{Sortie:} Liste $L$ des recommandations
        \State \textbf{\textit{Algorithme(M[1...n], u):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} $P \leftarrow$ Items pas encore achetés (\textbf{\textit{Algorithme 1}})
        \State \hspace{0.5cm} $clusters \leftarrow regrouper\_par\_cluster(M)$
        \State \hspace{0.5cm} $cf \leftarrow [vide]$
        \State \hspace{0.5cm} \textbf{Tant que} cf.length $<$ clusters.length:
        \State \hspace{1cm} $c \leftarrow cluster\_favoris(C, u)$
        \State \hspace{1cm} $cf.inserer(c)$
        \State \hspace{1cm} $C \leftarrow C.retirer(c)$
        \State \hspace{0.5cm} \textbf{Pour chaque} cluster $c$ $\in cf$:
        \State \hspace{1cm} $L.ajouter(P \cap c)$
        \State \hspace{0.5cm} \textbf{retourner} L
        \\
--------------------------------------------------------------------------------------------------------------------
        \State \textbf{\textit{cluster\_favoris(C[[1...n],[1...m],...k], u)}:}
        \State \hspace{0.5cm} $L \leftarrow [empty]$
        \State \hspace{0.5cm} \textbf{Pour chaque} cluster $c[1...n] \in C$:
        \State \hspace{1cm} $tmp \leftarrow [empty]$
        \State \hspace{1cm} \textbf{Pour chaque} repas $r \in c[1...n]$: 
        \State \hspace{2cm} \textbf{SI} $u \in r.likes$:
        \State \hspace{2.5cm} $tmp.ajouter(r)$
        \State \hspace{1cm} $L.ajouter(tmp.length)$
        \State \hspace{0.5cm} $i \leftarrow L.index\_du\_max$
        \State \hspace{0.5cm} \textbf{retourner} $C[i]$
        \\
--------------------------------------------------------------------------------------------------------------------
		\State \textbf{\textit{regrouper\_par\_cluster(M)}}:
		\State \hspace{0.5cm} $groupes \leftarrow \{vide\}$
		\State \hspace{0.5cm} \textbf{Pour chaque} item $\in M$:
		\State \hspace{1cm} \textbf{Si} $item.cluster \notin groupes$:
		\State \hspace{1.5cm} $groupes[item.cluster] = [vide]$
		\State \hspace{1cm} $groupes[item.cluster].inserer(item)$
		\State \hspace{0.5cm} \textbf{retourner} groupes 
		
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Knowledge based filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les spécifications de l'utilisateur.
        \Statex \textbf{Entrée:} Utilisateur actuel ($u$), Liste des repas du menu ($M$)
        \Statex \textbf{Sortie:} Liste des recommandations.
        \State \textbf{\textit{Algorithme(M[1...n], u):}}
        \State \hspace{0.5cm} $A \leftarrow u.liste\_allergens$
        \State \hspace{0.5cm} $allergenes \leftarrow repas\_allergens(A)$
        \State \hspace{0.5cm} $P \leftarrow u.preferences$
        \State \hspace{0.5cm} $R \leftarrow clusters(M)$ // \textbf{\textit{Algorithme 3}}
        \State \hspace{0.5cm} $E[0...n] \leftarrow$ récupérer les bons repas en fonction du régime (P[0]) et des
        \State \hspace{0.5cm} catégories (P[1]) spécifiées par l'utilisateur
        \State \hspace{0.5cm} \textbf{retourner} E
        \\
--------------------------------------------------------------------------------------------------------------------
        \State \textbf{\textit{repas\_allergenes(A[1...n], M[1...m]):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} \textbf{Pour chaque} repas $r\in M$:
        \State \hspace{1cm} \textbf{Si} $r.allergens \cap A \neq \emptyset$:
        \State \hspace{1.5cm} $L$.inserer(r)
        %\State \hspace{0.5cm} Trier les repas de $L$ en fonction du niveau de gravité
        \State \hspace{0.5cm} \textbf{retourner} $L$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Recommandation globale}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations à tout les utilisateurs.
        \Statex \textbf{Entrée:} Liste des repas du menu ($M$)
        \Statex \textbf{Sortie:} Liste des recommandations
        \State \textbf{\textit{Algorithme(M[1...n]):}}
        \State \hspace{0.5cm} $k \leftarrow$ nombre de repas à recommander
        \State \hspace{0.5cm} $I \leftarrow$ items les plus achetés
        \State \hspace{0.5cm} \textbf{retourner} $items\_plus\_aimes(I,k)$
        \\
--------------------------------------------------------------------------------------------------------------------
	\State \textbf{\textit{items\_plus\_aimes(I[1...n],k))}}:
	\State \hspace{0.5cm} $likes \leftarrow [vide]$
	\State \hspace{0.5cm} $res \leftarrow [vide]$
	\State \hspace{0.5cm} \textbf{Pour chaque} $item \in I$:
	\State \hspace{1cm} likes.insérer(item.likes.length)
	\State \hspace{0.5cm} \textbf{Pour} $i \leftarrow 0$ à $k$
	\State \hspace{1cm} $max\_like \leftarrow max(likes)$
	\State \hspace{1cm} $index \leftarrow likes.index(max\_likes)$ 
	\State \hspace{1cm} $res.inserer(I[index])$
	\State \hspace{1cm} $likes[index] \leftarrow -1$
	\State \hspace{0.5cm} \textbf{retourner} $res$
    \end{algorithmic}
\end{algorithm}



\end{document}
