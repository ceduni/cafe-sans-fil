\documentclass[11pt]{article}

\usepackage[french]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{array}
\usepackage{comment}

\begin{document}

\begin{center}
    \Large \textbf{Pseudo codes des algorithmes\\ de recommandation}
\end{center}

\section{Méthodes utilitaires}
\begin{algorithm}
    \caption{Repas pas encore consommés}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Menu du restaurant ($M$), utilisateur actuel ($u$)
    \Statex \textbf{Sortie:} Liste de repas
    \State \textbf{\textit{Algorithme(M[1...n], u)}}
    \State \hspace{0.5cm} $L \leftarrow u.historique\_achat$
    \State \hspace{0.5cm} \textbf{Pour chaque} repas $r \in L$
    \State \hspace{1cm} \textbf{Si} $r \in M$:
    \State \hspace{1.5cm} $M.retirer(r)$
    \State \hspace{0.5cm} \textbf{retourner} $M$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Mesure similarité: Jaccard}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Deux listes ou ensembles ($L_1, L_2$)
    \Statex \textbf{Sortie:} Nombre décimal représentant la similarité
    \State \textbf{\textit{Jaccard($L_1[1...n]$,$L_2[1...m]$):}}
    \State \hspace{0.5cm} $union \leftarrow L_1 \cup L_2$
    \State \hspace{0.5cm} $inter \leftarrow L_1 \cap L_2$
    \State \hspace{0.5cm} \textbf{retourner} $inter.length/union.length$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Clusters en fontion des préférences de l'utilisateur}
    \begin{algorithmic}[1]
    \Statex \textbf{Entrée:} Menu du restaurant ($M$)
    \Statex \textbf{Sortie:} Liste des régimes contenant les catégories de repas
    \State \textbf{\textit{clusters(M[1...n])}}
    \State \hspace{0.5cm} // Nous avons k régimes différents et p catégories de repas
    \State \hspace{0.5cm} $R \leftarrow [[0...n]...k]$
    \State \hspace{0.5cm} \textbf{Pour chaque} repas $r \in M$:
    \State \hspace{1cm} mettre le repas dans un ensemble en fonction de son régime
    \State \hspace{1cm} rajouter les différents régimes de repas à $R$
    \State \hspace{0.5cm} \textbf{Pour chaque} régime $T[1...\ell] \in R$ 
    \State \hspace{1cm} mettre chaque repas du même régime dans une catégorie 
    \State \hspace{0.5cm} \textbf{retourner} $R[[[0...n]...p]...k]$
    \end{algorithmic}
\end{algorithm}

\newpage
\section{Algorithmes principales}
\begin{algorithm}
    \caption{Collaborative filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les similarités entre utilisateurs.
        \Statex \textbf{Entrée:} Liste des utilisateurs de l'application ($U$), utilisateur ($u$)
        \Statex \textbf{Sortie:} Liste $L$ des recommandations
        \State \textbf{\textit{Algorithme(U[1...n], u):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} $\tau \leftarrow$ seuil de similarité 
        \State \hspace{0.5cm} $S \leftarrow U.retirer(u)$
        \State \hspace{0.5cm} $L_u \leftarrow$ [[u.likes], [u.repas\_consommés], [u.cafés\_visités]]
        \State \hspace{0.5cm} \textbf{Pour chaque} utilisateur $x\in S_{n\times 1}$
        \State \hspace{1cm} $L_x \leftarrow$ [[x.likes], [x.repas\_consommés], [x.cafés\_visités]]
        \State \hspace{1cm} $J \leftarrow [vide]$
        \State \hspace{1cm} \textbf{Pour} $i \leftarrow 0$ à $L_x.length$
        \State \hspace{1.5cm} $j \leftarrow Jaccard(L_u[i], L_x[i])$
        \State \hspace{1.5cm} $J.ajouter(j)$
        \State \hspace{1cm} $score \leftarrow sum(J)$
        \State \hspace{1cm} \textbf{Si} $score \geq \tau$:
        \State \hspace{1.5cm} $L \leftarrow (L_x[0] \cup L_x[1]) \backslash (L_u[0] \cup L_u[1])$
        \State \hspace{1cm} $S.retirer(x)$
        \State \hspace{0.5cm} \textbf{retourner} $L$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Content based filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les habitudes de consommation de l'utilisateur.
        \Statex \textbf{Entrée:} Menu du cafe ($M$), utilisateur ($u$)
        \Statex \textbf{Sortie:} Liste $L$ des recommandations
        \State \textbf{\textit{Algorithme(M[1...n], u):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} $P \leftarrow$ Items pas encore achetés (\textbf{\textit{Algorithme 1}})
        \State \hspace{0.5cm} $clusters \leftarrow regrouper\_par\_cluster(M)$
        \State \hspace{0.5cm} $cf \leftarrow [vide]$
        \State \hspace{0.5cm} \textbf{Tant que} cf.length $<$ clusters.length:
        \State \hspace{1cm} $c \leftarrow cluster\_favoris(C, u)$
        \State \hspace{1cm} $cf.inserer(c)$
        \State \hspace{1cm} $C \leftarrow C.retirer(c)$
        \State \hspace{0.5cm} \textbf{Pour chaque} cluster $c$ $\in cf$:
        \State \hspace{1cm} $L.ajouter(P \cap c)$
        \State \hspace{0.5cm} \textbf{retourner} L
        \\
--------------------------------------------------------------------------------------------------------------------
        \State \textbf{\textit{cluster\_favoris(C[[1...n],[1...m],...k], u)}:}
        \State \hspace{0.5cm} $L \leftarrow [empty]$
        \State \hspace{0.5cm} \textbf{Pour chaque} cluster $c[1...n] \in C$:
        \State \hspace{1cm} $tmp \leftarrow [empty]$
        \State \hspace{1cm} \textbf{Pour chaque} repas $r \in c[1...n]$: 
        \State \hspace{2cm} \textbf{SI} $u \in r.likes$:
        \State \hspace{2.5cm} $tmp.ajouter(r)$
        \State \hspace{1cm} $L.ajouter(tmp.length)$
        \State \hspace{0.5cm} $i \leftarrow L.index\_du\_max$
        \State \hspace{0.5cm} \textbf{retourner} $C[i]$
        \\
--------------------------------------------------------------------------------------------------------------------
		\State \textbf{\textit{regrouper\_par\_cluster(M)}}:
		\State \hspace{0.5cm} $groupes \leftarrow \{vide\}$
		\State \hspace{0.5cm} \textbf{Pour chaque} item $\in M$:
		\State \hspace{1cm} \textbf{Si} $item.cluster \notin groupes$:
		\State \hspace{1.5cm} $groupes[item.cluster] = [vide]$
		\State \hspace{1cm} $groupes[item.cluster].inserer(item)$
		\State \hspace{0.5cm} \textbf{retourner} groupes 
		
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Knowledge based filtering}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations basé sur les spécifications de l'utilisateur.
        \Statex \textbf{Entrée:} Utilisateur actuel ($u$), Liste des repas du menu ($M$)
        \Statex \textbf{Sortie:} Liste des recommandations.
        \State \textbf{\textit{Algorithme(M[1...n], u):}}
        \State \hspace{0.5cm} $A \leftarrow u.liste\_allergens$
        \State \hspace{0.5cm} $allergenes \leftarrow repas\_allergens(A)$
        \State \hspace{0.5cm} $P \leftarrow u.preferences$
        \State \hspace{0.5cm} $R \leftarrow clusters(M)$ // \textbf{\textit{Algorithme 3}}
        \State \hspace{0.5cm} $E[0...n] \leftarrow$ récupérer les bons repas en fonction du régime (P[0]) et des
        \State \hspace{0.5cm} catégories (P[1]) spécifiées par l'utilisateur
        \State \hspace{0.5cm} \textbf{retourner} E
        \\
--------------------------------------------------------------------------------------------------------------------
        \State \textbf{\textit{repas\_allergenes(A[1...n], M[1...m]):}}
        \State \hspace{0.5cm} $L \leftarrow [vide]$
        \State \hspace{0.5cm} \textbf{Pour chaque} repas $r\in M$:
        \State \hspace{1cm} \textbf{Si} $r.allergens \cap A \neq \emptyset$:
        \State \hspace{1.5cm} $L$.inserer(r)
        %\State \hspace{0.5cm} Trier les repas de $L$ en fonction du niveau de gravité
        \State \hspace{0.5cm} \textbf{retourner} $L$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Recommandation globale}
    \begin{algorithmic}[1]
        \Statex \textbf{Description:} Recommandations à tout les utilisateurs.
        \Statex \textbf{Entrée:} Liste des repas du menu ($M$)
        \Statex \textbf{Sortie:} Liste des recommandations
        \State \textbf{\textit{Algorithme(M[1...n]):}}
        \State \hspace{0.5cm} $k \leftarrow$ nombre de repas à recommander
        \State \hspace{0.5cm} $I \leftarrow$ items les plus achetés
        \State \hspace{0.5cm} \textbf{retourner} $items\_plus\_aimes(I,k)$
        \\
--------------------------------------------------------------------------------------------------------------------
	\State \textbf{\textit{items\_plus\_aimes(I[1...n],k))}}:
	\State \hspace{0.5cm} $likes \leftarrow [vide]$
	\State \hspace{0.5cm} $res \leftarrow [vide]$
	\State \hspace{0.5cm} \textbf{Pour chaque} $item \in I$:
	\State \hspace{1cm} likes.insérer(item.likes.length)
	\State \hspace{0.5cm} \textbf{Pour} $i \leftarrow 0$ à $k$
	\State \hspace{1cm} $max\_like \leftarrow max(likes)$
	\State \hspace{1cm} $index \leftarrow likes.index(max\_likes)$ 
	\State \hspace{1cm} $res.inserer(I[index])$
	\State \hspace{1cm} $likes[index] \leftarrow -1$
	\State \hspace{0.5cm} \textbf{retourner} $res$
    \end{algorithmic}
\end{algorithm}
\end{document}